<?php
/**
 * Filters <span> elements, generated by ICE
 */
class ICE_Span_Filter {
	private $text;

	const TOKEN_TEXT = 'text';
	const TOKEN_SPAN = 'span';
	const TOKEN_DEL = 'del';
	const TOKEN_INS = 'ins';
	const TOKEN_CLOSING = 'close';

	const STATE_IN_SPAN = 'in-span';
	const STATE_IN_INS = 'in-ins';
	const STATE_IN_DEL = 'in-del';

	var $tracking_css_classes;
	var $del_css_class;

	function __construct( $text, $tracking_css_classes ) {
		$this->text = $text;
		$this->tracking_css_classes = $tracking_css_classes;
	}

	/**
	 * Filters the text of the object
	 *
	 * - Removes both tags and their contents for <code>del</code> span tags
	 * - Removes tags, but leaves the content for <code>ins</code> span tags
	 * - Leaves the rest of the span tags alone
	 *
	 * Works as a simple state machine.
	 *
	 * @todo Deal with invalid span nesting
	 * @todo See if can break the method up, getting long
	 *
	 */
	function filter() {
		$state_stack = array();
		$result = '';

		foreach ( $this->get_tokens() as $token ) {
			switch ( $token->id ) {
			case self::TOKEN_DEL:
				array_push( $state_stack, self::STATE_IN_DEL );
				break;
			case self::TOKEN_INS:
				array_push( $state_stack, self::STATE_IN_INS );
				break;
			case self::TOKEN_SPAN:
				array_push( $state_stack, self::STATE_IN_SPAN );
				if ( !in_array( self::STATE_IN_DEL, $state_stack, true ) ) {
					$result .= $token->text;
				}
				break;
			case self::TOKEN_CLOSING:
				if ( self::STATE_IN_SPAN == array_pop( $state_stack ) && !in_array( self::STATE_IN_DEL, $state_stack, true ) ) {
					$result .= $token->text;
				}
				break;
			case self::TOKEN_TEXT:
				if ( !in_array( self::STATE_IN_DEL, $state_stack, true ) ) {
					$result .= $token->text;
				}
				break;
			}
		}

		$result = self::remove_empty_tags( $result );

		return $result;
	}

	/**
	 * Tokenizes (splits) the HTML into:
	 * 	- normal spans: opening span tag, which is neither an <code>ins</code>, not a <code>del</code>
	 * 	- ins spans: opening span tag with the insert tracking CSS class
	 * 	- del spans: opening span tag with the delete tracking CSS class
	 * 	- closing: a closing span tag
	 * 	- text: any other text or tags, which aren't relevant to our parsing
	 */
	function get_tokens() {
		$tokens = array();
		$parts = preg_split( '|(</?span[^>]*>)|', $this->text, -1, PREG_SPLIT_DELIM_CAPTURE );
		foreach( $parts as $token_text ) {
			if ( empty( $token_text ) ) {
				continue;
			}
			if ( '</span>' == $token_text ) {
				$id = self::TOKEN_CLOSING;
			} elseif ( 0 === strpos( $token_text, '<span' ) ) {
				$css_classes = self::get_css_classes($token_text);

				if ( in_array( $this->tracking_css_classes['ins'], $css_classes, true ) )
					$id = self::TOKEN_INS;
				elseif ( in_array( $this->tracking_css_classes['del'], $css_classes, true ) )
					$id = self::TOKEN_DEL;
				else
					$id = self::TOKEN_SPAN;
			} else {
				$id = self::TOKEN_TEXT;
			}
			$tokens[] = (object) array( 'id' => $id, 'text' => $token_text );
		}
		return $tokens;
	}

	static function get_css_classes( $tag ) {
		if ( preg_match( '/class\s*=\s*[\'"]([^\'"]+)[\'"]/', $tag, $matches ) )
			return preg_split( '/[ \r\n\t]+/', trim( $matches[1] ) );

		return array();
	}


	static function remove_empty_tags( $html ) {
		while ( preg_match( '/<(p|div|span|li|blockquote|h[1-6])\b[^>]*>[ \r\n\t]*<\/\\1>/', $html, $matches ) ) {
			$html = str_replace( $matches[0], '', $html );
		}
		return $html;
	}
}
